# webserver项目学习

Tags: C++项目, 代码随想录

## 本篇记录webserver项目代码与关键点实现

### fork原作者代码并拉取到本地

参考的仓库代码:https://github.com/qinguoyi/TinyWebServer

相当经典的C++项目

<!-- 具体操作详见  

[Git使用教程](https://www.notion.so/Git-94eadd4043184fb18d4314cb6703e492?pvs=21) -->

## 1. mysql数据库环境配置

### 1.1 环境安装与配置(ubuntu 20.04 x86架构)

参考链接: [https://ubuntu.com/server/docs/databases-mysql](https://ubuntu.com/server/docs/databases-mysql)

1. 先安装mysql-server: `sudo apt-get install mysql-server`
2. 安装完毕后, server将立即启动, 可以通过service查看
    
    ```bash
    sudo service mysql status'
    #输出如下
    ● mysql.service - MySQL Community Server
         Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset>
         Active: active (running) since Wed 2024-03-06 16:01:23 CST; 1min 4s ago
       Main PID: 166010 (mysqld)
         Status: "Server is operational"
          Tasks: 37 (limit: 28653)
         Memory: 364.6M
         CGroup: /system.slice/mysql.service
                 └─166010 /usr/sbin/mysqld
    
    3月 06 16:01:22 kototo systemd[1]: Starting MySQL Community Server...
    3月 06 16:01:23 kototo systemd[1]: Started MySQL Community Server.
    ```
    
3. 运行ss命令检查mysql运行状态 
    
    ```bash
    sudo ss -tap | grep mysql
    #输出如下, 返回运行程序的进程号,文件描述符与端口号 file descriptor
    LISTEN         0            70                             127.0.0.1:33060                          0.0.0.0:*       users:(("mysqld",pid=166010,fd=21))         
    LISTEN         0            151                            127.0.0.1:mysql                          0.0.0.0:*       users:(("mysqld",pid=166010,fd=23)) 
    ```
    
4. systemd journal 可以用来解决错误, 使用如下命令获取
    
    ```bash
    sudo journalctl -u mysql
    # 该命令也会记录之前安装过的mysql处理信息, 可也中;
    ```
    
5. 在 /etc/mysql 路径下可以配置基础设置, 如日志文件输出地址, 占用端口号等
    
    ```bash
    qjj@kototo:~$ cd /etc/mysql/
    qjj@kototo:/etc/mysql$ ls
    conf.d      debian-start  my.cnf.fallback  mysql.conf.d
    debian.cnf  my.cnf        mysql.cnf
    ```
    
6. 每次修改配置后需要重启服务, 可以用如下命令完成:
    
    ```bash
    sudo systemctl restart mysql.service
    ```
    

### 1.2 运行配置

- 使用sudo方法启动, 在数据库中建立本地用户或者远程用户:
    - 代码如下:
        
        ```bash
        sudo mysql
        #将会进入mysql console
        create user 'username'@'ip.address | localhost' identified by 'users_password';
        #举个例子
        create user 'qjj'@'localhost' identified by 'syqjj';
        #之后登录就可以使用用户名和密码了,非常方便
        mysql -u qjj -p
        passwd: 
        mysql>
        ```
        
- 创建数据库以方便跑项目代码:
    - 创建并添加两个表与实例:
        
        ```bash
        mysql -u qjj -p
        create database users_info
        use users_info
        create table user{
        username char(50),
        passwd char(50))Engine InnoDB;
        insert into user(username, passwd) value ('qjj', 'syqjj');
        ```
        
- 赋予用户权限:
    
    ```bash
    #使用grant为用户添加权限
    grant all on *.* to 'qjj'@'localhost';
    ```
    
- 现在即可开始测试webserver项目了；

### 1.3 卸载

参考链接: [https://askubuntu.com/questions/172514/how-do-i-uninstall-mysql](https://askubuntu.com/questions/172514/how-do-i-uninstall-mysql)

- 卸载前确保已停止MySQL服务
    
    ```bash
    sudo systemstl stop mysql
    ```
    
- 将相关的包都移除
    
    ```bash
    sudo apt-get purge mysql-server mysql-client mysql-common mysql-server-core-* mysql-client-core-*
    ```
    
- 删除MySQL相关的配置与数据, 如果自定义过data存储位置需要修改`/var/lib/mysql` 为你指定过的路径
    
    ```bash
    sudo rm -rf /etc/mysql /var/lib/mysql
    ```
    

### 1.4 打包成docker镜像方便部署

- [ ]  挖个坑, 准备写个动态网站自用, 放个轻量服务器上交流用；

### 1.5 需要安装cpp相关的lib才能调用mysql的头文件：

```cpp
sudo apt-get install libmysqlclient-dev
```

# 项目与代码理解

## 2. Tinywebserver项目总览

### 2.1 基础构成:

主要介绍一下项目的main, config与webserver主类；

**main.cpp:**

1. 定义了登录数据库的相关信息；
2. 实例化config读取命令行参数；
3. 实例化一个webserver, 传入登录数据库信息, 命令行参数等数据, 并调用webserver的日志写入, 数据库连接, 线程池, 触发模式, 监听, 运行等服务；
4. 调用时可以从命令行选取的参数如下:
    - p，自定义端口号, 默认9006
    - l，选择日志写入方式，默认同步写入
        - 0，同步写入
        - 1，异步写入
    - m，listenfd和connfd的模式组合，默认使用LT + LT
        - 0，表示使用LT + LT
        - 1，表示使用LT + ET
        - 2，表示使用ET + LT
        - 3，表示使用ET + ET
    - o，优雅关闭连接，默认不使用
        - 0，不使用
        - 1，使用
    - s，数据库连接数量, 默认为8
    - t，线程数量, 默认为8
    - c，关闭日志，默认打开
        - 0，打开日志
        - 1，关闭日志
    - a，选择反应堆模型，默认Proactor
        - 0，Proactor模型
        - 1，Reactor模型
- code:
    
    ```cpp
    #include "config.h"
    
    int main(int argc, char *argv[])
    {
        //需要修改的数据库信息,登录名,密码,库名
        string user = "qjj";
        string passwd = "syqjj";
        string databasename = "user_info";
    
        //命令行解析
        Config config;
        config.parse_arg(argc, argv);
    
        WebServer server;
    
        //初始化
        server.init(config.PORT, user, passwd, databasename, config.LOGWrite, 
                    config.OPT_LINGER, config.TRIGMode,  config.sql_num,  config.thread_num, 
                    config.close_log, config.actor_model);
        
    
        //日志
        server.log_write();
    
        //数据库
        server.sql_pool();
    
        //线程池
        server.thread_pool();
    
        //触发模式
        server.trig_mode();
    
        //监听
        server.eventListen();
    
        //运行
        server.eventLoop();
    
        return 0;
    }
    ```
    
1. 调用参数方法(在config内读入):
    - 头文件内通常包含的内容:
        1. 函数声明, 类和结构体的声明；
        2. 宏定义, 例如  #define pi 3.14 等；
        3. 模板定义:
            
            ```cpp
            template <typename T>
            class Array {
            public:
                Array(int size): size_(size), data_(new T[size]) {}
            
                ~Array() {
                    delete[] data_;
                }
            
                T& operator[](int index) {
                    return data_[index];
                }
            
                int size() const {
                    return size_;
                }
            
            private:
                int size_;
                T* data_;
            };
            ```
            
        4. 全局变量的声明；
    - config.h
        1. 使用 `#ifndef #define … #endif` 头文件保护方式防止重复include头文件, 进而防止符号重定义；
        2. 声明保存功能选项等信息的变量, 声明读取命令行参数的函数parse_arg；
        - 代码如下:
            
            ```cpp
            #ifndef CONFIG_H
            #define CONFIG_H
            
            #include "webserver.h"
            
            using namespace std;
            
            class Config
            {
            public:
                Config();
                ~Config(){};
            
                void parse_arg(int argc, char*argv[]);
            
                //端口号
                int PORT;
            
                //日志写入方式
                int LOGWrite;
            
                //触发组合模式
                int TRIGMode;
            
                //listenfd触发模式
                int LISTENTrigmode;
            
                //connfd触发模式
                int CONNTrigmode;
            
                //优雅关闭链接
                int OPT_LINGER;
            
                //数据库连接池数量
                int sql_num;
            
                //线程池内的线程数量
                int thread_num;
            
                //是否关闭日志
                int close_log;
            
                //并发模型选择
                int actor_model;
            };
            
            #endif
            ```
            
    - config.cpp
        1. 定义变量默认值, 定义函数:
        2. 注意该函数调用了 getopt() 方法
            
            `int getopt(int argc, char * const argv[], const char* str)` , argc为参数个数, argv为选项值数组, str是一个包含所有有效选项字符的字符串, 如果选项后有参数, 需要带上:
            
            ```cpp
            void Config::parse_arg(int argc, char*argv[]){
                int opt;
                const char *str = "p:l:m:o:s:t:c:a:";
                while ((opt = getopt(argc, argv, str)) != -1)
                {
                    switch (opt)
                    {
                    case 'p':
                    {
                        PORT = atoi(optarg);
                        break;
                    }
                    case 'l':
                    {
                        LOGWrite = atoi(optarg);
                        break;
                    }
                    ...
                    ...
                    default:
                        break;
                    }
                }
            }
            ```
            
        
2. webserver类功能概述:

**webserver.h**

- C++系统库调用

```cpp
#include <sys/socket.h>         //创建和操作socket的函数与数据结构
#include <netinet/in.h>         //Internet地址族的定义,如socket_in结构体
#include <arpa/inet.h>          //包含网络编程函数
#include <stdio.h>              //c标准库, scanf和printf在这里
#include <unistd.h>             //Unix系统调用库
#include <errno.h>              //包含errno变量,用于存储系统调用错误代码
#include <fcntl.h>              //文件控制函数库
#include <stdlib.h>             //malloc,free, exit函数在这
#include <cassert>              //assert宏,用于插入断言
#include <sys/epoll.h>          //包含epoll事件通知接口函数与数据结构
```

- 全局常量定义

```cpp
const int MAX_FD = 65536;           //最大文件描述符
const int MAX_EVENT_NUMBER = 10000; //最大事件数
const int TIMESLOT = 5;             //最小超时单位
```

- 类及其成员声明,这里就不放了

**webserver.cpp**

类构造, 析构, 成员函数定义, 按照main函数调用顺序进行分析:

- `server.log_write();` 日志记录函数:
    - 两个mode, 写不写日志和同步还是异步写入；
    - 该成员函数code如下:
    
    ```cpp
    void WebServer::log_write()
    {
        if (0 == m_close_log)
        {
            //初始化日志
            if (1 == m_log_write) //如果同步写入
            //这里用到了单例模式, 通过静态成员函数获取Log实例, 全局只有一个Log实例工作
                Log::get_instance()->init("./ServerLog", m_close_log, 2000, 800000, 800);
            else //异步写入
                Log::get_instance()->init("./ServerLog", m_close_log, 2000, 800000, 0);
        }
    }
    ```
    
    - 这里使用到了Log类单例, 需要对Log类进行理解:
    - 跳转~: [https://www.notion.so/webserver-1c70995b8a784a0b8142da4001180350?pvs=4#a8d3095656264fc9b8aa9b10ff0ecbfc](https://www.notion.so/webserver-1c70995b8a784a0b8142da4001180350?pvs=21)
- `server.sql_pool();` 数据库连接池初始化
    - 初始化数据库连接池与读取表
    - code如下:
    
    ```cpp
    void WebServer::sql_pool()
    {
        //初始化数据库连接池
        m_connPool = connection_pool::GetInstance();
        m_connPool->init("localhost", m_user, m_passWord, m_databaseName, 3306, m_sql_num, m_close_log);
    
        //初始化数据库读取表
        users->initmysql_result(m_connPool);
    }
    ```
    
    - 使用到connection_pool类实例, 需要学习一下:
    - 跳转~:

### 2.2 log类

三个文件, block_queue.h, log.h与log.cpp

1. block_queue.h
    - 是一个通过循环数组实现的阻塞队列,
    - code如下:
        
        ```cpp
        /*************************************************************
        *循环数组实现的阻塞队列，m_back = (m_back + 1) % m_max_size;  
        *线程安全，每个操作前都要先加互斥锁，操作完后，再解锁
        **************************************************************/
        
        #ifndef BLOCK_QUEUE_H
        #define BLOCK_QUEUE_H
        
        #include <iostream>
        #include <stdlib.h>
        #include <pthread.h>
        #include <sys/time.h>
        #include "../lock/locker.h"
        using namespace std;
        
        template <class T>
        class block_queue
        {
        public:
            block_queue(int max_size = 1000)
            {
                if (max_size <= 0)
                {
                    exit(-1);
                }
        
                m_max_size = max_size;
                m_array = new T[max_size];
                m_size = 0;
                m_front = -1;
                m_back = -1;
            }
        
            void clear()
            {
                m_mutex.lock();
                m_size = 0;
                m_front = -1;
                m_back = -1;
                m_mutex.unlock();
            }
        
            ~block_queue()
            {
                m_mutex.lock();
                if (m_array != NULL)
                    delete [] m_array;
        
                m_mutex.unlock();
            }
            //判断队列是否满了
            bool full() 
            {
                m_mutex.lock();
                if (m_size >= m_max_size)
                {
        
                    m_mutex.unlock();
                    return true;
                }
                m_mutex.unlock();
                return false;
            }
            //判断队列是否为空
            bool empty() 
            {
                m_mutex.lock();
                if (0 == m_size)
                {
                    m_mutex.unlock();
                    return true;
                }
                m_mutex.unlock();
                return false;
            }
            //返回队首元素
            bool front(T &value) 
            {
                m_mutex.lock();
                if (0 == m_size)
                {
                    m_mutex.unlock();
                    return false;
                }
                value = m_array[m_front];
                m_mutex.unlock();
                return true;
            }
            //返回队尾元素
            bool back(T &value) 
            {
                m_mutex.lock();
                if (0 == m_size)
                {
                    m_mutex.unlock();
                    return false;
                }
                value = m_array[m_back];
                m_mutex.unlock();
                return true;
            }
        
            int size() 
            {
                int tmp = 0;
        
                m_mutex.lock();
                tmp = m_size;
        
                m_mutex.unlock();
                return tmp;
            }
        
            int max_size()
            {
                int tmp = 0;
        
                m_mutex.lock();
                tmp = m_max_size;
        
                m_mutex.unlock();
                return tmp;
            }
            //往队列添加元素，需要将所有使用队列的线程先唤醒
            //当有元素push进队列,相当于生产者生产了一个元素
            //若当前没有线程等待条件变量,则唤醒无意义
            bool push(const T &item)
            {
        
                m_mutex.lock();
                if (m_size >= m_max_size)
                {
        
                    m_cond.broadcast();
                    m_mutex.unlock();
                    return false;
                }
        
                m_back = (m_back + 1) % m_max_size;
                m_array[m_back] = item;
        
                m_size++;
        
                m_cond.broadcast();
                m_mutex.unlock();
                return true;
            }
            //pop时,如果当前队列没有元素,将会等待条件变量
            bool pop(T &item)
            {
        
                m_mutex.lock();
                while (m_size <= 0)
                {
                    
                    if (!m_cond.wait(m_mutex.get()))
                    {
                        m_mutex.unlock();
                        return false;
                    }
                }
        
                m_front = (m_front + 1) % m_max_size;
                item = m_array[m_front];
                m_size--;
                m_mutex.unlock();
                return true;
            }
        
            //增加了超时处理
            bool pop(T &item, int ms_timeout)
            {
                struct timespec t = {0, 0};
                struct timeval now = {0, 0};
                gettimeofday(&now, NULL);
                m_mutex.lock();
                if (m_size <= 0)
                {
                    t.tv_sec = now.tv_sec + ms_timeout / 1000;
                    t.tv_nsec = (ms_timeout % 1000) * 1000;
                    if (!m_cond.timewait(m_mutex.get(), t))
                    {
                        m_mutex.unlock();
                        return false;
                    }
                }
        
                if (m_size <= 0)
                {
                    m_mutex.unlock();
                    return false;
                }
        
                m_front = (m_front + 1) % m_max_size;
                item = m_array[m_front];
                m_size--;
                m_mutex.unlock();
                return true;
            }
        
        private:
            locker m_mutex;
            cond m_cond;
        
            T *m_array;
            int m_size;
            int m_max_size;
            int m_front;
            int m_back;
        };
        
        #endif
        
        ```
        
    - 声明一个模板类, 用于实现阻塞队列:
        - 除了构造函数外其他函数都上互斥锁；
        - 调用了locker.h类:跳转:
        - 空满判断, 队首队尾值返回, 已用空间大小, push和pop；
2. log类:
    - 内部私有成员函数包括:
        
        ```cpp
        private:
            Log();
            virtual ~Log();
            void *async_write_log()
            {
                string single_log;
                //从阻塞队列中取出一个日志string，写入文件
                while (m_log_queue->pop(single_log))
                {
                    m_mutex.lock();
                    fputs(single_log.c_str(), m_fp);
                    m_mutex.unlock();
                }
            }
        ```
        
    - 内部私有成员变量包括:
        
        ```cpp
        private:
            char dir_name[128]; //路径名
            char log_name[128]; //log文件名
            int m_split_lines;  //日志最大行数
            int m_log_buf_size; //日志缓冲区大小
            long long m_count;  //日志行数记录
            int m_today;        //因为按天分类,记录当前时间是那一天
            FILE *m_fp;         //打开log的文件指针
            char *m_buf;
            block_queue<string> *m_log_queue; //阻塞队列
            bool m_is_async;                  //是否同步标志位
            locker m_mutex;
            int m_close_log; //关闭日志
        ```
        
    - 定义了debug, info, warning, error在日志中写入的操作:
        
        ```cpp
        #define LOG_DEBUG(format, ...) if(0 == m_close_log) {Log::get_instance()->write_log(0, format, ##__VA_ARGS__); Log::get_instance()->flush();}
        #define LOG_INFO(format, ...) if(0 == m_close_log) {Log::get_instance()->write_log(1, format, ##__VA_ARGS__); Log::get_instance()->flush();}
        #define LOG_WARN(format, ...) if(0 == m_close_log) {Log::get_instance()->write_log(2, format, ##__VA_ARGS__); Log::get_instance()->flush();}
        #define LOG_ERROR(format, ...) if(0 == m_close_log) {Log::get_instance()->write_log(3, format, ##__VA_ARGS__); Log::get_instance()->flush();}
        ```
        
    - 共有成员函数:
        
        ```cpp
        public:
            //C++11以后,使用局部变量懒汉不用加锁
            static Log *get_instance()
            {
                static Log instance;
                return &instance;
            }
        
            static void *flush_log_thread(void *args)
            {
                Log::get_instance()->async_write_log();
            }
            //可选择的参数有日志文件、日志缓冲区大小、最大行数以及最长日志条队列
            bool init(const char *file_name, int close_log, int log_buf_size = 8192, int split_lines = 5000000, int max_queue_size = 0);
        
            void write_log(int level, const char *format, ...);
        
            void flush(void);
        ```
        
3. log类功能实现:
    - log.cpp拆解各部分代码:
        - 初始化函数:
            
            ```cpp
            //初始化函数:
            bool Log::init(const char *file_name, int close_log, int log_buf_size, int split_lines, int max_queue_size)
            {
                //如果设置了max_queue_size,则设置为异步
                if (max_queue_size >= 1)
                {
                    m_is_async = true;
                    m_log_queue = new block_queue<string>(max_queue_size);
                    pthread_t tid;
                    //flush_log_thread为回调函数,这里表示创建线程异步写日志
                    //flush_log_thread函数调用了Log单例的异步写入功能,一直从阻塞队列中读数据并写入日志文件
                    pthread_create(&tid, NULL, flush_log_thread, NULL);
                }
                
                m_close_log = close_log;
                m_log_buf_size = log_buf_size;
                m_buf = new char[m_log_buf_size];
                memset(m_buf, '\0', m_log_buf_size);
                m_split_lines = split_lines;
            
                time_t t = time(NULL);
                struct tm *sys_tm = localtime(&t);
                struct tm my_tm = *sys_tm;
                //获取本地时间赋值给my_tm变量, time按秒返回自1970.1.1的时间, localtime返回本地时间结构体指针
            
             
                const char *p = strrchr(file_name, '/');
                //查找最后一次出现'/'的地方
                char log_full_name[256] = {0};
            
                if (p == NULL)
                {
            		    //snprintf可以用于格式化写入字符串, 三个参数: 字符串地址, 最大长度和格式
                    snprintf(log_full_name, 255, "%d_%02d_%02d_%s", my_tm.tm_year + 1900, my_tm.tm_mon + 1, my_tm.tm_mday, file_name);
                }
                else
                {
                    strcpy(log_name, p + 1);
                    strncpy(dir_name, file_name, p - file_name + 1);
                    snprintf(log_full_name, 255, "%s%d_%02d_%02d_%s", dir_name, my_tm.tm_year + 1900, my_tm.tm_mon + 1, my_tm.tm_mday, log_name);
                }
            
                m_today = my_tm.tm_mday;
                
                m_fp = fopen(log_full_name, "a");
                if (m_fp == NULL)
                {
                    return false;
                }
            
                return true;
            }
            ```
            
        - 写日志:
            
            ```cpp
            void Log::write_log(int level, const char *format, ...)
            {
                struct timeval now = {0, 0};
                gettimeofday(&now, NULL);
                time_t t = now.tv_sec;
                struct tm *sys_tm = localtime(&t);
                struct tm my_tm = *sys_tm;
                char s[16] = {0};
                switch (level)
                {
                case 0:
                    strcpy(s, "[debug]:");
                    break;
                case 1:
                    strcpy(s, "[info]:");
                    break;
                case 2:
                    strcpy(s, "[warn]:");
                    break;
                case 3:
                    strcpy(s, "[erro]:");
                    break;
                default:
                    strcpy(s, "[info]:");
                    break;
                }
                //写入一个log，对m_count++, m_split_lines最大行数
                m_mutex.lock();
                m_count++;
            
                if (m_today != my_tm.tm_mday || m_count % m_split_lines == 0) //everyday log
                {
                    
                    char new_log[256] = {0};
                    fflush(m_fp);
                    fclose(m_fp);
                    char tail[16] = {0};
                   
                    snprintf(tail, 16, "%d_%02d_%02d_", my_tm.tm_year + 1900, my_tm.tm_mon + 1, my_tm.tm_mday);
                   
                    if (m_today != my_tm.tm_mday)
                    {
                        snprintf(new_log, 255, "%s%s%s", dir_name, tail, log_name);
                        m_today = my_tm.tm_mday;
                        m_count = 0;
                    }
                    else
                    {
                        snprintf(new_log, 255, "%s%s%s.%lld", dir_name, tail, log_name, m_count / m_split_lines);
                    }
                    m_fp = fopen(new_log, "a");
                }
             
                m_mutex.unlock();
            
                va_list valst;
                va_start(valst, format);
            
                string log_str;
                m_mutex.lock();
            
                //写入的具体时间内容格式
                int n = snprintf(m_buf, 48, "%d-%02d-%02d %02d:%02d:%02d.%06ld %s ",
                                 my_tm.tm_year + 1900, my_tm.tm_mon + 1, my_tm.tm_mday,
                                 my_tm.tm_hour, my_tm.tm_min, my_tm.tm_sec, now.tv_usec, s);
                
                int m = vsnprintf(m_buf + n, m_log_buf_size - n - 1, format, valst);
                m_buf[n + m] = '\n';
                m_buf[n + m + 1] = '\0';
                log_str = m_buf;
            
                m_mutex.unlock();
            
                if (m_is_async && !m_log_queue->full())
                {
                    m_log_queue->push(log_str);
                }
                else
                {
                    m_mutex.lock();
                    fputs(log_str.c_str(), m_fp);
                    m_mutex.unlock();
                }
            
                va_end(valst);
            }
            ```
            

### locker.h

- 使用sem类封装了posix信号量操作；
- 使用locker类封装了posix互斥锁操作；
- 使用cond类封装了posix条件变量的操作；
- code如下
    
    ```cpp
    #ifndef LOCKER_H
    #define LOCKER_H
    
    #include <exception>
    #include <pthread.h>
    #include <semaphore.h>
    
    class sem
    {
    public:
        sem()
        {
            if (sem_init(&m_sem, 0, 0) != 0)
            {
                throw std::exception();
            }
        }
        sem(int num)
        {
            if (sem_init(&m_sem, 0, num) != 0)
            {
                throw std::exception();
            }
        }
        ~sem()
        {
            sem_destroy(&m_sem);
        }
        bool wait()
        {
            return sem_wait(&m_sem) == 0;
        }
        bool post()
        {
            return sem_post(&m_sem) == 0;
        }
    
    private:
        sem_t m_sem;
    };
    class locker
    {
    public:
        locker()
        {
            if (pthread_mutex_init(&m_mutex, NULL) != 0)
            {
                throw std::exception();
            }
        }
        ~locker()
        {
            pthread_mutex_destroy(&m_mutex);
        }
        bool lock()
        {
            return pthread_mutex_lock(&m_mutex) == 0;
        }
        bool unlock()
        {
            return pthread_mutex_unlock(&m_mutex) == 0;
        }
        pthread_mutex_t *get()
        {
            return &m_mutex;
        }
    
    private:
        pthread_mutex_t m_mutex;
    };
    class cond
    {
    public:
        cond()
        {
            if (pthread_cond_init(&m_cond, NULL) != 0)
            {
                //pthread_mutex_destroy(&m_mutex);
                throw std::exception();
            }
        }
        ~cond()
        {
            pthread_cond_destroy(&m_cond);
        }
        bool wait(pthread_mutex_t *m_mutex)
        {
            int ret = 0;
            //pthread_mutex_lock(&m_mutex);
            ret = pthread_cond_wait(&m_cond, m_mutex);
            //pthread_mutex_unlock(&m_mutex);
            return ret == 0;
        }
        bool timewait(pthread_mutex_t *m_mutex, struct timespec t)
        {
            int ret = 0;
            //pthread_mutex_lock(&m_mutex);
            ret = pthread_cond_timedwait(&m_cond, m_mutex, &t);
            //pthread_mutex_unlock(&m_mutex);
            return ret == 0;
        }
        bool signal()
        {
            return pthread_cond_signal(&m_cond) == 0;
        }
        bool broadcast()
        {
            return pthread_cond_broadcast(&m_cond) == 0;
        }
    
    private:
        //static pthread_mutex_t m_mutex;
        pthread_cond_t m_cond;
    };
    #endif
    
    ```
    

### 2.3 connection_pool类

- 两个文件, 经典的头文件声明, cpp文件实现:
    - 同样以单例模式运行, 整个程序运行过程中只有一个数据库连接池实例；
    - 声明了一个资源初始化类, 从connect pool中获取一个MySQL连接, 目的是确保资源的获取和释放与对象的生命周期绑定，从而确保资源的正确管理；
- 头文件sql_connection_pool.h
    - 头文件调用:
    
    ```cpp
    #ifndef _CONNECTION_POOL_
    #define _CONNECTION_POOL_
    
    #include <stdio.h>
    #include <list>
    #include <mysql/mysql.h>
    #include <error.h>
    #include <string.h>
    #include <iostream>
    #include <string>
    #include "../lock/locker.h"
    #include "../log/log.h"
    
    using namespace std;
    ```
    
    - 连接池类定义:
    
    ```cpp
    class connection_pool
    {
    public:
    	MYSQL *GetConnection();				 //获取数据库连接
    	bool ReleaseConnection(MYSQL *conn); //释放连接
    	int GetFreeConn();					 //获取连接
    	void DestroyPool();					 //销毁所有连接
    
    	//单例模式
    	static connection_pool *GetInstance();
    
    	void init(string url, string User, string PassWord, string DataBaseName, int Port, int MaxConn, int close_log); 
    
    private:
    	connection_pool();
    	~connection_pool();
    
    	int m_MaxConn;  //最大连接数
    	int m_CurConn;  //当前已使用的连接数
    	int m_FreeConn; //当前空闲的连接数
    	locker lock;
    	list<MYSQL *> connList; //连接池
    	sem reserve;
    
    public:
    	string m_url;			 //主机地址
    	string m_Port;		 //数据库端口号
    	string m_User;		 //登陆数据库用户名
    	string m_PassWord;	 //登陆数据库密码
    	string m_DatabaseName; //使用数据库名
    	int m_close_log;	//日志开关
    };
    ```
    
    - 连接实现类:
    
    ```cpp
    class connectionRAII{
    
    public:
    	connectionRAII(MYSQL **con, connection_pool *connPool);
    	~connectionRAII();
    	
    private:
    	MYSQL *conRAII;
    	connection_pool *poolRAII;
    };
    
    #endif
    ```
    

#