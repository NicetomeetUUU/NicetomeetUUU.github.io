---
title: "线程池在webserver中的实现"
date: 2024-01-03
description: "Linux下轻量级服务器实现记录-线程池部分"
type: "post"
tags: ["C++项目", "blog", "webserver轻量级服务器"]
---

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<!-- **Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)* -->

- [1. 线程池总览](#1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%80%BB%E8%A7%88)
- [2. 代码详解](#2-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3)
  - [2.1 线程池对象可直接调用的成员函数包括`append`和`append-p`：](#21-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AF%B9%E8%B1%A1%E5%8F%AF%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%8C%85%E6%8B%ACappend%E5%92%8Cappend-p)
  - [2.2 线程池对象构造与析构函数](#22-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0)
  - [2.3 worker函数：](#23-worker%E5%87%BD%E6%95%B0)
- [3. 总结：](#3-%E6%80%BB%E7%BB%93)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 1. 线程池总览
- 实现了一个基于生产者-消费者模型的线程池：
    - 生产者是调用`append`或者`append-p`方法的线程；
    - 消费者是线程池中的工作线程，在`run`方法中循环等待任务出现；

## 2. 代码详解
- 类总览：
    ```c++
    template <typename T>
    class threadpool
    {
    public:
        /*thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*/
        threadpool(int actor_model, connection_pool *connPool, int thread_number = 8, int max_request = 10000);
        ~threadpool();
        bool append(T *request, int state);
        bool append_p(T *request);

    private:
        /*工作线程运行的函数，它不断从工作队列中取出任务并执行之*/
        static void *worker(void *arg);
        void run();

    private:
        int m_thread_number;        //线程池中的线程数
        int m_max_requests;         //请求队列中允许的最大请求数
        pthread_t *m_threads;       //描述线程池的数组，其大小为m_thread_number
        std::list<T *> m_workqueue; //请求队列
        locker m_queuelocker;       //保护请求队列的互斥锁
        sem m_queuestat;            //是否有任务需要处理
        connection_pool *m_connPool;  //数据库
        int m_actor_model;          //模型切换
    };
    ```
    - 维护最大请求数、线程数、线程池数组（线程指针）、请求队列、互斥锁、信号量实现的待处理任务记录、数据库链接池、模型类型（Reactor or Proactor）；
### 2.1 线程池对象可直接调用的成员函数包括`append`和`append-p`：
- append函数，用于Reactor模式，直接读取http请求并添加任务到工作队列；

    ```c++
    template <typename T>
    bool threadpool<T>::append(T *request, int state)
    //传入参数：要添加的任务：request、任务状态：state（0表示读、其他写）
    //使用队列互斥锁保障同一时间只有一个任务请求可以得到工作队列
    {
        m_queuelocker.lock();
        if (m_workqueue.size() >= m_max_requests)
        {
            m_queuelocker.unlock();
            return false;
        }
        request->m_state = state;
        m_workqueue.push_back(request);
        m_queuelocker.unlock();
        m_queuestat.post();
        return true;
    }
    ```
- append_p，用于Proactor模式，没有request状态

    ```c++
    template <typename T>
    bool threadpool<T>::append_p(T *request)
    //Proactor模式下，添加任务线程不需要确定任务状态，默认预先已知
    {
        m_queuelocker.lock();
        if (m_workqueue.size() >= m_max_requests)
        {
            m_queuelocker.unlock();
            return false;
        }
        m_workqueue.push_back(request);
        m_queuelocker.unlock();
        m_queuestat.post();
        return true;
    }
    ```
### 2.2 线程池对象构造与析构函数
- threadpool()
    ```c++
    template <typename T>
        threadpool<T>::threadpool( int actor_model, connection_pool *connPool, int thread_number, int max_requests) : m_actor_model(actor_model),m_thread_number(thread_number), m_max_requests(max_requests), m_threads(NULL),m_connPool(connPool)
        {
            if (thread_number <= 0 || max_requests <= 0)
                throw std::exception();
            m_threads = new pthread_t[m_thread_number];
            if (!m_threads)
                throw std::exception();
            for (int i = 0; i < thread_number; ++i)
            {
                if (pthread_create(m_threads + i, NULL, worker, this) != 0)
                //给static类型的worker传递自身指针，thread_number个工作线程均共享一个threadpool；
                {
                    delete[] m_threads;
                    throw std::exception();
                }
                if (pthread_detach(m_threads[i]))
                //未成功回收资源，则自己回收工作线程并抛出异常；
                {
                    delete[] m_threads;
                    throw std::exception();
                }
            }
        }
    template <T>
    threadpool<T>::~threadpool(){
        delete []m_threads;
    }
    ```
- 在pthread_create中调用了worker函数，为该函数传递了threadpool对象的指针；
### 2.3 worker函数：
- worker函数是工作线程的默认回调函数，处理消息请求
    - 调用了run函数，无限循环在线程池中读请求消息并处理
    ```c++
        void *threadpool<T>::worker(void *arg)
        //不能设定为非static函数，非static函数需要隐含的this指针指向调用它的对象
        //而pthread_create必须操作全局函数；
        //同样的也是为了让所有工作线程共享一个线程池函数
        {
            threadpool *pool = (threadpool *)arg;
            pool->run();
            return pool;
        }
        template <typename T>
    ```
    - run函数如下，根据当前的actor模式完成不同操作
    ```c++
        void threadpool<T>::run()
        {
            while (true)
            {
                m_queuestat.wait();
                m_queuelocker.lock();
                if (m_workqueue.empty())
                {
                    m_queuelocker.unlock();
                    continue;
                }
                T *request = m_workqueue.front();
                m_workqueue.pop_front();
                m_queuelocker.unlock();
                if (!request)
                    continue;
                if (1 == m_actor_model)
                {
                    if (0 == request->m_state)
                    {
                        if (request->read_once())
                        {
                            request->improv = 1;
                            connectionRAII mysqlcon(&request->mysql, m_connPool);
                            request->process();
                        }
                        else
                        {
                            request->improv = 1;
                            request->timer_flag = 1;
                        }
                    }
                    else
                    {
                        if (request->write())
                        {
                            request->improv = 1;
                        }
                        else
                        {
                            request->improv = 1;
                            request->timer_flag = 1;
                        }
                    }
                }
                else
                {
                    connectionRAII mysqlcon(&request->mysql, m_connPool);
                    request->process();
                }
            }
        }
    ``` 

## 3. 总结：
1. threadpool()维护了一个工作线程池，在有消息请求到来后自动处理；
2. 使用信号量监听消息请求队列是否有请求发生；
3. 使用互斥量保证同一时刻只有一个线程在读消息请求队列；
4. 工作线程先拿请求，后处理
5. 需要进一步了解Reactor模式与Proactor模式：
    - [高性能网络系统](../操作系统学习/网络系统部分.md)
