---
title: "各类线程锁在webserver中的实现"
date: 2023-12-20
description: "Linux下轻量级服务器实现记录-线程锁部分"
type: "post"
tags: ["C++项目", "blog", "webserver轻量级服务器"]
---

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<!-- **Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)* -->

- [1. 线程锁总览](#1-%E7%BA%BF%E7%A8%8B%E9%94%81%E6%80%BB%E8%A7%88)
  - [简述：](#%E7%AE%80%E8%BF%B0)
- [2. 代码实现](#2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0)
  - [2.1 sem信号量控制类](#21-sem%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%8E%A7%E5%88%B6%E7%B1%BB)
  - [2.2 locker互斥锁类](#22-locker%E4%BA%92%E6%96%A5%E9%94%81%E7%B1%BB)
  - [2.3 cond条件变量设置](#23-cond%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE)
- [3. 总结](#3-%E6%80%BB%E7%BB%93)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->


## 1. 线程锁总览
- 使用 信号量、互斥量、条件变量 实现线程锁
- 封装为类，在超出作用域可以自动析构，保证线程安全

### 简述：
1. 互斥锁（Mutex）：主要用于保护共享资源，防止多个线程同时访问。一个线程在访问共享资源前需要获取互斥锁，访问结束后释放互斥锁。如果其他线程在这个时候也试图获取互斥锁，它会被阻塞直到互斥锁被释放。

2. 信号量（Semaphore）：主要用于限制对共享资源的访问数量。信号量内部维护了一个计数器，线程在访问共享资源前需要调用wait（或P）操作，访问结束后调用post（或V）操作。如果计数器的值为0，wait操作会阻塞线程直到计数器的值大于0。

3. 条件变量（Condition Variable）：主要用于线程间的条件同步。线程可以在条件不满足时调用wait操作被阻塞，其他线程在条件满足后调用signal或broadcast操作唤醒被阻塞的线程。条件变量通常和互斥锁一起使用，互斥锁用于保护条件的状态，条件变量用于等待和通知条件的改变。

4. 条件变量和信号量之间的区别：
条件变量更适合用于"等待某个条件成立"的场景，而信号量更适合用于"限制对共享资源的并发访问数量"的场景

## 2. 代码实现

### 2.1 sem信号量控制类
- 构造函数析构函数没得说
- wait函数用来等待信号量，当信号量值大于0，sem_wait立即返回0，否则返回非0值；
- post函数释放资源，使信号量增加，并且唤醒等待中的进程；
```c++
class sem
{
public:
    sem()
    {
        if (sem_init(&m_sem, 0, 0) != 0)
        {
            throw std::exception();
        }
    }
    sem(int num)
    {
        if (sem_init(&m_sem, 0, num) != 0)
        {
            throw std::exception();
        }
    }
    ~sem()
    {
        sem_destroy(&m_sem);
    }
    bool wait()
    {
        return sem_wait(&m_sem) == 0;
    }
    bool post()
    {
        return sem_post(&m_sem) == 0;
    }

private:
    sem_t m_sem;
};
```

### 2.2 locker互斥锁类
- 构造函数、析构函数
- lock()、unlock()、get()；
    - lock调用的锁在无法获取互斥资源时会阻塞；如果想阻塞时刻直接返回，可以使用try_lock函数
    - get函数能够获取锁状态，但是破坏了类的封装性；
```c++
class locker
{
public:
    locker()
    {
        if (pthread_mutex_init(&m_mutex, NULL) != 0)
        {
            throw std::exception();
        }
    }
    ~locker()
    {
        pthread_mutex_destroy(&m_mutex);
    }
    bool lock()
    {
        return pthread_mutex_lock(&m_mutex) == 0;
        //
    }
    bool unlock()
    {
        return pthread_mutex_unlock(&m_mutex) == 0;
    }
    pthread_mutex_t *get()
    {
        return &m_mutex;
    }

private:
    pthread_mutex_t m_mutex;
};
```

### 2.3 cond条件变量设置
- 使用外部定义的互斥锁保障条件状态修改的安全性；
```c++
class cond
{
public:
    cond()
    {
        if (pthread_cond_init(&m_cond, NULL) != 0)
        {
            //pthread_mutex_destroy(&m_mutex);
            throw std::exception();
        }
    }
    ~cond()
    {
        pthread_cond_destroy(&m_cond);
    }
    bool wait(pthread_mutex_t *m_mutex)
    {
        int ret = 0;
        ret = pthread_cond_wait(&m_cond, m_mutex);
        //通过外部互斥锁保障对cond访问的安全性
        return ret == 0;
    }
    bool timewait(pthread_mutex_t *m_mutex, struct timespec t)
    {
        int ret = 0;
        ret = pthread_cond_timedwait(&m_cond, m_mutex, &t);
        //多了一个时间结构体，限定时间内未获取条件资源，则返回非0值
        return ret == 0;
    }
    bool signal()
    {
        return pthread_cond_signal(&m_cond) == 0;
        //随机唤醒一个等待的线程
    }
    bool broadcast()
    {
        return pthread_cond_broadcast(&m_cond) == 0;
        //唤醒所有等待条件变量的线程
    }

private:
    //static pthread_mutex_t m_mutex;
    pthread_cond_t m_cond;
};
```

## 3. 总结
- 互斥锁保障独立访问
- 信号量设为1，其实和互斥锁差不多，但是多了个唤醒操作；
- 条件变量与互斥锁绑定使用，信号量常用于限制共享资源上线程的并发数量；条件变量则用于等待某条件成立的情况；
- 条件变量timedwait机制是，段时间内睡眠线程，线程等待条件变量后唤醒；段时间后，线程自动唤醒并继续执行后续操作；