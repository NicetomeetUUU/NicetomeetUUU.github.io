---
title: "日志系统在webserver中的实现"
date: 2023-12-27
description: "Linux下轻量级服务器实现记录-日志系统部分"
type: "post"
tags: ["C++项目", "blog", "webserver轻量级服务器"]
---
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<!-- **Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)* -->

- [1. 日志系统总览](#1-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E6%80%BB%E8%A7%88)
- [2. 代码实现](#2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0)
  - [2.1 阻塞队列](#21-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97)
  - [2.2 log类](#22-log%E7%B1%BB)
    - [2.2.1 示例获取get_instance()](#221-%E7%A4%BA%E4%BE%8B%E8%8E%B7%E5%8F%96get_instance)
    - [2.2.2 异步缓冲区写入flush_log_thread()](#222-%E5%BC%82%E6%AD%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E5%86%99%E5%85%A5flush_log_thread)
  - [2.3 log类的共有成员函数](#23-log%E7%B1%BB%E7%9A%84%E5%85%B1%E6%9C%89%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0)
    - [1. 初始化函数：](#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0)
    - [2. `Log::write_log()`：写日志。这个函数接受一个日志级别和一个格式化字符串，然后生成一条日志并写入日志文件或者阻塞队列。如果当前日期不是今天，或者日志文件的行数达到了最大值，那么会创建一个新的日志文件。](#2-logwrite_log%E5%86%99%E6%97%A5%E5%BF%97%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%97%E4%B8%80%E4%B8%AA%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB%E5%92%8C%E4%B8%80%E4%B8%AA%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%84%B6%E5%90%8E%E7%94%9F%E6%88%90%E4%B8%80%E6%9D%A1%E6%97%A5%E5%BF%97%E5%B9%B6%E5%86%99%E5%85%A5%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E4%B8%8D%E6%98%AF%E4%BB%8A%E5%A4%A9%E6%88%96%E8%80%85%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%9A%84%E8%A1%8C%E6%95%B0%E8%BE%BE%E5%88%B0%E4%BA%86%E6%9C%80%E5%A4%A7%E5%80%BC%E9%82%A3%E4%B9%88%E4%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6)
    - [3. `Log::flush()`：刷新日志。这个函数会强制将日志缓冲区的内容写入日志文件。](#3-logflush%E5%88%B7%E6%96%B0%E6%97%A5%E5%BF%97%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E4%BC%9A%E5%BC%BA%E5%88%B6%E5%B0%86%E6%97%A5%E5%BF%97%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%86%85%E5%AE%B9%E5%86%99%E5%85%A5%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6)
- [3. 总结：](#3-%E6%80%BB%E7%BB%93)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 1. 日志系统总览
- 首先通过循环数组实现了一个阻塞队列
- log类工作在单例模式下，单例模式详解如下：
    - [单例模式](../设计模式学习/单例模式.md)
- 日志写入可以选择同步模式（线程自身调用函数打印日志）、也可以选择异步模式（将日志输入阻塞队列，待写入线程处理，阻塞队列实际上是FIFO的模式，根据线程调度先后写入，不保障顺序）；
- 使用互斥锁保护日志文件与日志缓冲区，保障每一时刻只有一个线程写入日志；

## 2. 代码实现
### 2.1 阻塞队列
- 阻塞队列每次操作数组前，通过互斥锁维护线程安全；
- 构造函数：阻塞队列有最大值，初始化时刻将构造一个最大值大小数组，size设为0，队头指针与队尾指针设为-1；
- 析构函数：析构直接释放循环数组；
- 就是通过首尾指针在maxsize上的遍历与size对元素总量的记录实现队列中数据的流入与流出

### 2.2 log类
#### 2.2.1 示例获取get_instance()
```c++
    static Log *get_instance()
    {
        static Log instance;
        return &instance;
    }
```

#### 2.2.2 异步缓冲区写入flush_log_thread()
```C++
    static void *flush_log_thread(void *args)
    {
        Log::get_instance()->async_write_log();
    }
private:
    void *async_write_log()
    {
        string single_log;
        //从阻塞队列中取出一个日志string，写入文件
        while (m_log_queue->pop(single_log))
        {
            m_mutex.lock();
            fputs(single_log.c_str(), m_fp);
            m_mutex.unlock();
        }
    }
```

### 2.3 log类的共有成员函数
#### 1. 初始化函数：
- 初始化日志系统。这个函数接受几个参数，包括日志文件的名字、是否关闭日志、日志缓冲区的大小、日志文件的最大行数和阻塞队列的最大大小。如果设置了阻塞队列的最大大小，那么日志系统会运行在异步模式下，否则会运行在同步模式下。
```c++
bool Log::init(const char *file_name, int close_log, int log_buf_size, int split_lines, int max_queue_size)
{
    //如果设置了max_queue_size,则设置为异步
    if (max_queue_size >= 1)
    {
        m_is_async = true;
        m_log_queue = new block_queue<string>(max_queue_size);
        pthread_t tid;
        //flush_log_thread为回调函数,这里表示创建线程异步写日志
        pthread_create(&tid, NULL, flush_log_thread, NULL);
    }
    
    m_close_log = close_log;
    m_log_buf_size = log_buf_size;
    m_buf = new char[m_log_buf_size];
    memset(m_buf, '\0', m_log_buf_size);
    m_split_lines = split_lines;

    time_t t = time(NULL);
    struct tm *sys_tm = localtime(&t);
    struct tm my_tm = *sys_tm;

 
    const char *p = strrchr(file_name, '/');
    char log_full_name[256] = {0};

    if (p == NULL)
    {
        snprintf(log_full_name, 255, "%d_%02d_%02d_%s", my_tm.tm_year + 1900, my_tm.tm_mon + 1, my_tm.tm_mday, file_name);
    }
    else
    {
        strcpy(log_name, p + 1);
        strncpy(dir_name, file_name, p - file_name + 1);
        snprintf(log_full_name, 255, "%s%d_%02d_%02d_%s", dir_name, my_tm.tm_year + 1900, my_tm.tm_mon + 1, my_tm.tm_mday, log_name);
    }

    m_today = my_tm.tm_mday;
    
    m_fp = fopen(log_full_name, "a");
    if (m_fp == NULL)
    {
        return false;
    }

    return true;
}
```

#### 2. `Log::write_log()`：写日志。这个函数接受一个日志级别和一个格式化字符串，然后生成一条日志并写入日志文件或者阻塞队列。如果当前日期不是今天，或者日志文件的行数达到了最大值，那么会创建一个新的日志文件。
```c++
void Log::write_log(int level, const char *format, ...)
{
    struct timeval now = {0, 0};
    gettimeofday(&now, NULL);
    time_t t = now.tv_sec;
    struct tm *sys_tm = localtime(&t);
    struct tm my_tm = *sys_tm;
    char s[16] = {0};
    switch (level)
    {
    case 0:
        strcpy(s, "[debug]:");
        break;
    case 1:
        strcpy(s, "[info]:");
        break;
    case 2:
        strcpy(s, "[warn]:");
        break;
    case 3:
        strcpy(s, "[erro]:");
        break;
    default:
        strcpy(s, "[info]:");
        break;
    }
    //写入一个log，对m_count++, m_split_lines最大行数
    m_mutex.lock();
    m_count++;

    if (m_today != my_tm.tm_mday || m_count % m_split_lines == 0) //everyday log
    {
        
        char new_log[256] = {0};
        fflush(m_fp);
        fclose(m_fp);
        char tail[16] = {0};
       
        snprintf(tail, 16, "%d_%02d_%02d_", my_tm.tm_year + 1900, my_tm.tm_mon + 1, my_tm.tm_mday);
       
        if (m_today != my_tm.tm_mday)
        {
            snprintf(new_log, 255, "%s%s%s", dir_name, tail, log_name);
            m_today = my_tm.tm_mday;
            m_count = 0;
        }
        else
        {
            snprintf(new_log, 255, "%s%s%s.%lld", dir_name, tail, log_name, m_count / m_split_lines);
        }
        m_fp = fopen(new_log, "a");
    }
 
    m_mutex.unlock();

    va_list valst;
    va_start(valst, format);

    string log_str;
    m_mutex.lock();

    //写入的具体时间内容格式
    int n = snprintf(m_buf, 48, "%d-%02d-%02d %02d:%02d:%02d.%06ld %s ",
                     my_tm.tm_year + 1900, my_tm.tm_mon + 1, my_tm.tm_mday,
                     my_tm.tm_hour, my_tm.tm_min, my_tm.tm_sec, now.tv_usec, s);
    
    int m = vsnprintf(m_buf + n, m_log_buf_size - n - 1, format, valst);
    m_buf[n + m] = '\n';
    m_buf[n + m + 1] = '\0';
    log_str = m_buf;

    m_mutex.unlock();

    if (m_is_async && !m_log_queue->full())
    {
        m_log_queue->push(log_str);
    }
    else
    {
        m_mutex.lock();
        fputs(log_str.c_str(), m_fp);
        m_mutex.unlock();
    }

    va_end(valst);
}
```
#### 3. `Log::flush()`：刷新日志。这个函数会强制将日志缓冲区的内容写入日志文件。
```c++
void Log::flush(void)
{
    m_mutex.lock();
    //强制刷新写入流缓冲区
    fflush(m_fp);
    m_mutex.unlock();
}
```

## 3. 总结：
1. write_log会被多个线程同时调用，异步就写入阻塞队列，同步就直接fputs写入；